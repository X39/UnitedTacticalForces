@using System.ComponentModel.DataAnnotations
@using System.Diagnostics.Contracts
@using MudBlazor.Utilities
@using X39.UnitedTacticalForces.Contract.Event
@using X39.UnitedTacticalForces.WebApp.Api.Models
@using X39.UnitedTacticalForces.WebApp.Data
@using X39.UnitedTacticalForces.WebApp.Services.EventRepository
@using X39.UnitedTacticalForces.WebApp.Services.SlotRepository
@using X39.UnitedTacticalForces.WebApp.Services.UserRepository
@using X39.Util
@inject IEventRepository EventRepository
@inject ISlotRepository SlotRepository
@inject IDialogService DialogService
<MudTooltip IsVisibleChanged="LoadToolTipContentAsync" ShowOnClick="false" ShowOnFocus="@(AcceptanceCount > 0)"
            ShowOnHover="@(AcceptanceCount > 0)">
    <TooltipContent>
        <MudStack Style="max-height: 50rem">
            @if (_users is null)
            {
                for (var i = 0; i < AcceptanceCount; i++)
                {
                    <MudSkeleton Height="3rem" Width="16rem"/>
                }
            }
            else
            {
                foreach (var user in _users)
                {
                    <UtfUser PlainUser="@user"/>
                }
            }
        </MudStack>
    </TooltipContent>
    <ChildContent>
        @if (AcceptanceCount > 0)
        {
            <MudBadge Content="@(AcceptanceCount)"
                      Color="@ToggledColor"
                      Overlap="true"
                      BadgeClass="mx-n2 my-n2">
                <MudToggleIconButton Icon="@Icon"
                                     ToggledIcon="@Icon"
                                     Color="@UnToggledColor"
                                     ToggledColor="@ToggledColor"
                                     Toggled="@(Event.PlainEvent.MetaAcceptance == (int) Acceptance)"
                                     ToggledChanged="AcceptanceChangedAsync"
                                     Disabled="Disabled"/>
            </MudBadge>
        }
        else
        {
            <MudToggleIconButton Icon="@Icon"
                                 ToggledIcon="@Icon"
                                 Color="@UnToggledColor"
                                 ToggledColor="@ToggledColor"
                                 Toggled="@(Event.PlainEvent.MetaAcceptance == (int) Acceptance)"
                                 ToggledChanged="AcceptanceChangedAsync"
                                 Disabled="Disabled"/>
        }
    </ChildContent>
</MudTooltip>

@code {
    private IReadOnlyCollection<PlainUserDto>? _users;
    private bool                               _pollingUsers;


    [Parameter]
    public bool Disabled { get; set; }

    [Parameter, Required, EditorRequired]
    public Event Event { get; set; } = null!;

    [Parameter, Required, EditorRequired]
    public EEventAcceptance Acceptance { get; set; }

    [Parameter, Required, EditorRequired]
    public EventCallback ParentStateHasChangedCallback { get; set; }

    private Color UnToggledColor
        => Acceptance switch
        {
            EEventAcceptance.Rejected => Color.Default,
            EEventAcceptance.Maybe    => Color.Default,
            EEventAcceptance.Accepted => Color.Default,
            _                         => throw new ArgumentOutOfRangeException(),
        };

    private Color ToggledColor
        => Acceptance switch
        {
            EEventAcceptance.Rejected => Color.Error,
            EEventAcceptance.Maybe    => Color.Tertiary,
            EEventAcceptance.Accepted => Color.Primary,
            _                         => throw new ArgumentOutOfRangeException(),
        };

    [Parameter, EditorRequired, Required]
    public int? AcceptanceCount { get; set; }

    /*
    private int AcceptanceCount => Acceptance switch
    {
        EEventAcceptance.Rejected => Event.RejectedCount ?? 0,
        EEventAcceptance.Maybe => Event.MaybeCount ?? 0,
        EEventAcceptance.Accepted => Event.AcceptedCount ?? 0,
        _ => throw new ArgumentOutOfRangeException(),
        };
    */


    private string Icon
        => Acceptance switch
        {
            EEventAcceptance.Rejected => Icons.Material.Filled.Clear,
            EEventAcceptance.Maybe    => Icons.Material.Filled.QuestionMark,
            EEventAcceptance.Accepted => Icons.Material.Filled.Check,
            _                         => throw new ArgumentOutOfRangeException(),
        };

    private async Task AcceptanceChangedAsync()
    {
        if (Acceptance is not EEventAcceptance.Accepted)
        {
            var slot = await SlotRepository.MySlotAsync(Event.PlainEvent.PrimaryKey!.Value)
                .ConfigureAwait(false);
            if (slot is not null)
            {
                var result = await Dialogs.ConfirmSlotLoss
                    .ShowAsync(DialogService)
                    .ConfigureAwait(false);
                if (!result)
                    return;
            }
        }

        Contract.Assert(Event.PlainEvent.PrimaryKey is not null);
        var userMeta = (EEventAcceptance?) Event.PlainEvent.MetaAcceptance;
        if (userMeta == Acceptance)
            return;
        await EventRepository.SetMeAcceptanceAsync(Event.PlainEvent.PrimaryKey.Value, Acceptance)
            .ConfigureAwait(false);

        if (userMeta is not null)
        {
            switch (userMeta)
            {
                case EEventAcceptance.Rejected:
                    Event.PlainEvent.RejectedCount--;
                    break;
                case EEventAcceptance.Maybe:
                    Event.PlainEvent.MaybeCount--;
                    break;
                case EEventAcceptance.Accepted:
                    Event.PlainEvent.AcceptedCount--;
                    break;
                case null:
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            userMeta = Acceptance;
        }
        else
        {
            Event.PlainEvent.MetaAcceptance = (int) Acceptance;
        }

        switch (Acceptance)
        {
            case EEventAcceptance.Rejected:
                Event.PlainEvent.RejectedCount++;
                break;
            case EEventAcceptance.Maybe:
                Event.PlainEvent.MaybeCount++;
                break;
            case EEventAcceptance.Accepted:
                Event.PlainEvent.AcceptedCount++;
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }

        await ParentStateHasChangedCallback.InvokeAsync();
    }

    private async Task LoadToolTipContentAsync(bool arg)
    {
        if (arg && _users is null && !_pollingUsers)
        {
            using var disposable = new Disposable(() => _pollingUsers = true, () => _pollingUsers = false);
            _users = await EventRepository.GetEventParticipantsAsync(Event.PlainEvent.PrimaryKey!.Value, Acceptance)
                .ConfigureAwait(false);
        }
    }

}
